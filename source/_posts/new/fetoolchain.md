layout: art
title: 聊一聊前端工具链
subtitle: 
tags: 
- 工具
categories: 
- 前端工程化
date: 2020/3/25
---

最近主要开发流程的构建工具被要求进行升级，从平台化的方案修改到npm提供的CLI命令行工具，这个修改本人是非常不赞同的，是历史的倒退，在这里说一下自己的看法。

<!-- more -->

CLI工具链本质上就是注册一个全局bin文件，命令行运行命令时系统查找到bin文件后执行其中的逻辑，并将后续的参数放入process.argv中，程序解析argv后基于自己对于命令行参数的定义来决定运行什么了子逻辑。通常我们都会基于开源界通用的命令行规范进行argv的解析，比较火的库比如tj的commander就以描述的方式对参数进行解析并对应到各个子逻辑的action。

对于子逻辑，通常也就是子命令，决定了工具链所能提供的能力，我之前在[聊一聊前端研发流程](https://lingyu.life/#/post/2020/3/25/new/fedevprocess)这篇文章中介绍过前端研发流程，对应的各个步骤都会体现在子命令上，比如：
- 项目初始化：init
- 项目代码开发：dev
- 项目构建编译：build
- 项目自动化测试：test
- 项目资源发布：publish

而这仅仅是前端研发流程本地部分的核心链路，其实还有很多周边的链路，比如coverge、doc等等都可以封装成CLI工具。这对于工具链本身就需要很好地扩展性，也就是将CLI工具从宏内核向微内核转变。

## 宏内核的工具链

宏内核的工具链很好理解，将所有的研发流程的需求都放在一个CLI工具中，形成一站式本地研发解决方案。

这种模式一般常见于开源的一些工具，以及规模较小的团队，或者团队早期。由于负责的业务形态较为单一，研发流程相对固定，因此一个定制化的CLI工具就能解决所有的问题。

但随着业务、团队的发展场景逐渐复杂，各个业务场景对研发流程的需求逐渐增加，因此首先想到的是，增加配置文件来干预工具链的运行流程。但继续发展下去，很快就会发现配置文件其实很难满足所有需求，而且配置文件的维护会变得很痛苦，因此会转而考虑通过增加命令来实现研发流程的扩展。这就需要微内核的工具链方案了

## 微内核的工具链

微内核与宏内核工具链的差距主要就是在于插件机制。通常我们会抽离出一个core模块，来做以下工作：
- 插件加载
- argv解析
- 配置读取
- 插件运行
- 日志管理
- 临时文件管理

### 插件加载

运行后，内核首先会去查找插件，通过遍历如下文件夹，根据名称或package.json中的标识来定位插件，通过require加载并注册：
- 内置插件：内核自身的node_modules
- 全局插件：`npm root -g`的全局安装位置
- 仓库本地插件：`${cwd}/node_modules`的本地node_modules

### argv解析

argv解析过程主要是确定子命令查找对应插件，若找到对应插件，则需要读取本地配置并将配置与当前命令参数一起交给插件运行。而找不到插件的情况下，应当给与插件不存在的提示并给出插件安装的推荐方案。

### 配置读取

通常一个CLI工具链只会有一个配置文件，因此若找到了需要运行的插件，那么内核应该读取配置文件，并找到该插件所对应的配置内容，交由插件执行。这里配置读取的过程其实是有两个，一个是内置的默认配置，一个是仓库本地配置。在仓库本地没有配置的情况下使用默认配置。

### 插件运行

插件运行也有两种模式，一种是直接以函数的方式运行，另外一种是通过`child_process`开启子进程来运行。子进程的方式可以做到更好的运行环境隔离，而且对于一些非node技术栈很友好。而函数方式运行则可以更好的做管控，比如日志注入。

### 日志管理

插件运行过程中的日志管理其实还是挺重要的，在提升用户体验的同时，也方便开发者在插件运行出现问题的时候进行排查。毕竟工具链安装在每个用户的电脑上，他们的环境多多少少有些不同，node版本、系统版本、网络环境等等。

日志管理其实蛮复杂的，比如构建插件，它自己并不是真的去构建代码，而是使用webpack等等工具来进行构建，因此如何将这些工具输出的日志也能统一起来，就有点蛋疼了。而且同时也需要将这些日志输出到临时文件中，来方便排查问题。一般会采用拦截stdout和stderr两个输出流的方式来实现，对应child_process创建的子进程也需要用inherit来处理。

而日志一般都会定义等级，verbose、info、success、warn、error、debug，对应不同的输出颜色。这里就如果需要子命令也按照对应等级输出，一种是开发时基于统一的log模块，另一种由内核进行log模块的注入。

### 临时文件管理

很多插件在运行环境下都会产生一些临时文件，比如资源代理时防止重复请求、比如构建流程的中间产物等等，如果这些插件都乱输出临时文件，那么很容易搞得项目目录乱七八糟，因此核心模块应当将插件的临时文件目录传入插件，并提供临时文件目录的一键删除能力

##### 微内核的问题

微内核的方案能够实现命令级别的扩展，主要针对研发流程的补充。但随着业务的发展我们发现很多时候流程大体相似，但只是构建的流程会做一些小的扩展，比如有的同学想在当前的构建流程上增加TypeScript、有些同学想修改一下本地调试的渲染模板。在宏内核与微内核的CLI命令中，这些能力要么是通过脚手架初始化生成到仓库本地，亦或是是现在build的子命令中。生成到本地无法动态升级和复用，实现在build中则缺乏扩展性。因此需要将将构建的流程单独抽离出来进行管理。

## 脚手架和构建器

当我们将构建流程从脚手架和子命令中剥离，形成单独的构建器。构建器内包含构建流程以及构建所需要的依赖工具，构建流程大体相同，唯一额外要处理的就是需要同时处理好构建器自身的依赖以及仓库本地的依赖，保证两边都能正常加载。

而剥离了构建器的脚手架，基本上就只剩源码、源码的运行依赖及源码开发相关的配置了。剥离了构建器的构建命令，则主要是负责构建器的加载，检测构建器的版本并提示构建器升级。比较通用的方式就是将构建器发布到npm，通过访问npm的开放API拿到最新版本，与本地版本匹配后下载tar包解压安装。加载构建器过程与加载插件本质上差不多，可以理解为构建子命令自身也是一个微内核。

这种方式其实本质上是一种SaaS模式，其中的软件也就是构建器，而软件下发就是npm + 子命令的构建器升级机制，用户无需持有、也无需关心构建器，只需要知道有这么个东西在帮助他们构建即可。

## 从SaaS到SaaS

而这种软件即服务的方式，可以进一步进化到解决方案即服务，也就是Solution as a Service。这两者的区别主要在于，软件即服务下，使用者还是会感知到构建器的存在并去手动使用它，虽然它能够动态的更新和维护，但使用者并没有专注在自己的工作中，还是有一些额外的工作。

实际上代码开发者完全无需感知构建流程的存在，他们只是订阅了构建服务，这个服务于帮他们处理构建这个事情。但对于构建的流程是完全无感知的，他们无需升级，无需安装，无需运行，这就是云构建的模式。使用者只关心本地的代码开发，也就是自己的本职工作，除此之外不再有感知，这是最好的方案。这种方案未来也可以向WebIDE进行转变。也非常适合做开放化，引入三方能力进行开发。

## 前端工具链的演化

其实前端的工具链完全可以全部转变成解决方案即服务，用户编码的同时，代码会发送到云端，生成实时的渲染结果返回。整个工具链都跑在云端，代码编辑也确实能放在云端，但我认为未来代码编辑也就是WebIDE本身还是会受到网速与Webkit渲染能力的限制，如果WASM能够突破Webkit的渲染限制，同时网速能够更加快速，WebIDE加一直整套的云端工具链方式将会成为主流。

